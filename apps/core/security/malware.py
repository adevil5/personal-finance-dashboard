"""
Malware scanning utilities for file uploads.

This module provides malware scanning capabilities for uploaded files
using various scanning engines and techniques.
"""

import hashlib
import logging
import subprocess
import tempfile
from typing import Any, Dict, List

logger = logging.getLogger(__name__)


class MalwareScanError(Exception):
    """Exception raised when malware scanning fails."""

    pass


def scan_file(file_obj) -> Dict[str, Any]:
    """
    Scan a file for malware using available scanning engines.

    Args:
        file_obj: Django UploadedFile or FieldFile object to scan

    Returns:
        Dict containing scan results:
        {
            'is_clean': bool,
            'threats': List[str],
            'scanner': str,
            'scan_time': float
        }

    Raises:
        MalwareScanError: If scanning fails
    """
    import time

    start_time = time.time()

    try:
        # Try ClamAV first if available
        if _is_clamav_available():
            result = _scan_with_clamav(file_obj)
            result["scanner"] = "clamav"
            result["scan_time"] = time.time() - start_time
            return result

        # Fallback to signature-based detection
        result = _scan_with_signatures(file_obj)
        result["scanner"] = "signatures"
        result["scan_time"] = time.time() - start_time
        return result

    except Exception as e:
        logger.error(f"Malware scan failed: {e}")
        raise MalwareScanError(f"Scan failed: {e}")


def _is_clamav_available() -> bool:
    """Check if ClamAV is available on the system."""
    try:
        subprocess.run(
            ["clamscan", "--version"], capture_output=True, check=True, timeout=5
        )
        return True
    except (
        subprocess.CalledProcessError,
        FileNotFoundError,
        subprocess.TimeoutExpired,
    ):
        return False


def _scan_with_clamav(file_obj) -> Dict[str, Any]:
    """
    Scan file using ClamAV engine.

    Args:
        file_obj: Django UploadedFile object

    Returns:
        Dict with scan results
    """
    with tempfile.NamedTemporaryFile(delete=False) as temp_file:
        try:
            # Write file content to temporary file
            try:
                # Try using chunks() method first (for UploadedFile)
                for chunk in file_obj.chunks():
                    temp_file.write(chunk)
            except (AttributeError, TypeError):
                # Fallback for FieldFile objects
                file_obj.seek(0)
                content = file_obj.read()
                temp_file.write(content)
                file_obj.seek(0)
            temp_file.flush()

            # Run ClamAV scan
            result = subprocess.run(
                ["clamscan", "--no-summary", temp_file.name],
                capture_output=True,
                text=True,
                timeout=30,  # 30 second timeout
            )

            # Parse results
            if result.returncode == 0:
                return {"is_clean": True, "threats": []}
            elif result.returncode == 1:
                # Virus found
                threats = _parse_clamav_output(result.stdout)
                return {"is_clean": False, "threats": threats}
            else:
                # Error occurred
                raise MalwareScanError(f"ClamAV error: {result.stderr}")

        except subprocess.TimeoutExpired:
            raise MalwareScanError("ClamAV scan timeout")
        finally:
            # Clean up temp file
            try:
                import os

                os.unlink(temp_file.name)
            except OSError:
                pass


def _parse_clamav_output(output: str) -> List[str]:
    """Parse ClamAV output to extract threat names."""
    threats = []
    for line in output.split("\n"):
        if "FOUND" in line:
            # Extract threat name from line like: "file.exe: Threat.Name FOUND"
            parts = line.split(":")
            if len(parts) >= 2:
                threat_part = parts[1].replace("FOUND", "").strip()
                threats.append(threat_part)
    return threats


def _scan_with_signatures(file_obj) -> Dict[str, Any]:
    """
    Scan file using signature-based detection.

    This is a fallback method that checks for known malicious signatures.

    Args:
        file_obj: Django UploadedFile or FieldFile object

    Returns:
        Dict with scan results
    """
    # Read file content
    try:
        file_obj.seek(0)
        content = file_obj.read()
        file_obj.seek(0)  # Reset position
    except (AttributeError, IOError):
        # Handle FieldFile objects
        if hasattr(file_obj, "file") and hasattr(file_obj.file, "read"):
            file_obj.file.seek(0)
            content = file_obj.file.read()
            file_obj.file.seek(0)
        else:
            # Can't read file, assume it's clean
            return {"is_clean": True, "threats": []}

    # Check file signatures
    threats = []

    # Check for executable signatures
    if content.startswith(b"MZ"):  # Windows PE executable
        threats.append("Suspicious.PE.Executable")

    if content.startswith(b"\x7fELF"):  # Linux ELF executable
        threats.append("Suspicious.ELF.Executable")

    if content.startswith(b"\xcf\xfa\xed\xfe"):  # Mach-O executable
        threats.append("Suspicious.MachO.Executable")

    # Check for script signatures
    script_signatures = [
        (b"<script", "Suspicious.HTML.Script"),
        (b"javascript:", "Suspicious.JavaScript.URI"),
        (b"vbscript:", "Suspicious.VBScript.URI"),
        (b"<?php", "Suspicious.PHP.Script"),
        (b"<%", "Suspicious.ASP.Script"),
    ]

    content_lower = content.lower()
    for signature, threat_name in script_signatures:
        if signature in content_lower:
            threats.append(threat_name)

    # Check for known malicious patterns
    malicious_patterns = [
        (b"eval(", "Suspicious.Eval.Pattern"),
        (b"document.write", "Suspicious.DocumentWrite.Pattern"),
        (b"shell_exec", "Suspicious.ShellExec.Pattern"),
        (b"system(", "Suspicious.System.Pattern"),
        (b"base64_decode", "Suspicious.Base64Decode.Pattern"),
    ]

    for pattern, threat_name in malicious_patterns:
        if pattern in content_lower:
            threats.append(threat_name)

    # Check file hash against known malicious hashes
    file_hash = hashlib.sha256(content).hexdigest()
    if _is_malicious_hash(file_hash):
        threats.append("Known.Malicious.Hash")

    return {"is_clean": len(threats) == 0, "threats": threats}


def _is_malicious_hash(file_hash: str) -> bool:
    """
    Check if file hash is in known malicious hash database.

    In a production environment, this would query an external
    threat intelligence service or local database.
    """
    # Known malicious hashes (example - in production use real threat intel)
    malicious_hashes = {
        # Empty file
        "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
        # Add more known malicious hashes here
    }

    return file_hash.lower() in malicious_hashes


def get_file_hash(file_obj) -> str:
    """
    Calculate SHA256 hash of uploaded file.

    Args:
        file_obj: Django UploadedFile or FieldFile object

    Returns:
        SHA256 hash as hex string
    """
    try:
        file_obj.seek(0)
        content = file_obj.read()
        file_obj.seek(0)  # Reset position
    except (AttributeError, IOError):
        # Handle FieldFile objects
        if hasattr(file_obj, "file") and hasattr(file_obj.file, "read"):
            file_obj.file.seek(0)
            content = file_obj.file.read()
            file_obj.file.seek(0)
        else:
            # Can't read file, return empty hash
            return hashlib.sha256(b"").hexdigest()

    return hashlib.sha256(content).hexdigest()


def is_suspicious_filename(filename: str) -> bool:
    """
    Check if filename contains suspicious patterns.

    Args:
        filename: Name of the uploaded file

    Returns:
        True if filename is suspicious
    """
    suspicious_patterns = [
        ".exe",
        ".scr",
        ".com",
        ".bat",
        ".cmd",
        ".pif",
        ".vbs",
        ".js",
        ".jar",
        ".app",
        ".deb",
        ".pkg",
        ".dmg",
        ".iso",
        ".msi",
        ".ps1",
        ".sh",
        ".pl",
    ]

    filename_lower = filename.lower()

    # Check for suspicious extensions
    for pattern in suspicious_patterns:
        if filename_lower.endswith(pattern):
            return True

    # Check for double extensions (e.g., file.txt.exe)
    parts = filename_lower.split(".")
    if len(parts) > 2:
        for part in parts[
            1:-1
        ]:  # Skip first part (filename) and last part (real extension)
            if part in [ext.lstrip(".") for ext in suspicious_patterns]:
                return True

    return False
